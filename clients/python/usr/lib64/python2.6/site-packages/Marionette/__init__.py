import socket
import time

class Client(object):
    '''Client library to talk to Marionette Server

import Marionette
mc = Marionette.Client(port=9990, host="127.0.0.1", debug=0)
err_code = mc.execute('command.name', args....)
    '''

    # char separators
    CTRL_A = chr(1)		# arg sep
    CTRL_E = chr(5)		# command sep
    
    # status codes
    START_DONUT_BAKING = "200"	# started the command 
    END_DONUT_BAKING   = "201"	# ended successfully
    NO_DONUT_BAKING    = "100"	# execute failed, could be any reason (EXEC didn't happen) 
    NO_DONUT_FOR_YOU   = "101"  # no command found
    ERR_DONUT_EXEC     = "102"  # execvp failed
    ERR_DONUT_BAKING   = "103"  # exec command failed
    
    err_table = {
        "200" : "START_DONUT_BAKING",
        "201" : "END_DONUT_BAKING",
        "100" : "NO_DONUT_BAKING",
        "101" : "NO_DONUT_FOR_YOU",
        "102" : "ERR_DONUT_EXEC",
        "103" : "ERR_DONUT_BAKING",
        }
    
    def __init__(self, host=None, port=None, timeout=None, debug=None):
        """Creates an interface to talk to Marionette Server
        
        mc = Marionette.Client()

        Arguments to __init__ are 
        * host    (remote marionette host, default "127.0.0.1")
        * port    (default 9990)
        * debug   (default 0)
        * timeout (socket timeout, default 900)
        """
        # create socket
        self.sock = socket.socket(
            socket.AF_INET, socket.SOCK_STREAM)

        # set timeout
        if timeout: self.sock.settimeout(timeout)
        else: self.sock.settimeout(900)
        
        self.sock.setblocking(1)

        if debug: self.debug = 1
        else: self.debug = 0

        # make a connection
        if not host: host = "127.0.0.1"
        if not port: port = 9990
        self.sock.connect((host, port,))


        # init result
        self.errmsg = ''
        self.errcode = 0
        self.result = ''
        self.runtime = -1

        return

    def __del__(self):
        """On out of scope of object, socket is closed
        """
        self.sock.close()

    def _reset_result(self):
        self.errmsg = ''
        self.errcode = 0
        self.result = ''
        self.runtime = -1

        return

    # damn, no references in python (or atleast i don't know howto)
    def _execute(self, cmd):
        end = 0
        # send the data
        sent = self.sock.send(cmd)
        if sent == 0:
                raise RuntimeError("socket connection broken")

        # get the start padding
        chunk = self.sock.recv(3)
        if chunk == '':
            raise RuntimeError("socket connection broken")

        # now i iterate till we are good
        while not end:
            import sys
            if self.debug: sys.stderr.write(chunk)
            end = self._continue(chunk)
            if not end:
                chunk = self.sock.recv(512)
                if chunk == '':
                    raise RuntimeError("socket connection broken")
            else:
                break

        self.result = self.result[:-3] # remove the padding

        self.runtime = time.time() - self.runtime;

        return self.errcode
                

    def _continue(self, recv):
        
        self.result += recv; # there is a chance that we got last 3 chars in 2 flights
        e_pad = self.result[-3:] # take the last 3 chars
        
        end = 1;

        if e_pad == "200":      # 200 is for starting
            self.result = '';   # unset data
            end = 0
        elif e_pad == "201":
            end = 1;
        elif e_pad == "100" or e_pad == "101" or e_pad == "102" or e_pad == "103":
            end = 1
            self.errmsg = Client.err_table[e_pad]
            self.errcode  = int(e_pad)
        else:
            end = 0
        
        return end
            

    # this is the function exposed outside to users
    def execute(self, command, *args):
        """Executes the command on the remote Marionette Server.
        Expects: 1 command, followed by 0 or more args to marionette
        eg, 

        err_code = obj.execute("test.echo", "-n", "foo")

        The only exposed function is 'execute'. It executes the command on the marionette server (remote host). 
        For each execute, following data is set in the object as per the status of previous execute.

        self.errmsg = ''
        self.errcode = 0
        self.result = ''
        self.runtime = -1       # time taken for previos execute

        The Error Code Mapping is as follows

        START_DONUT_BAKING = "200"  # started the command  
        END_DONUT_BAKING   = "201"  # ended successfully 
        NO_DONUT_BAKING    = "100"  # execute failed, could be any reason (EXEC didn't happen) 
        NO_DONUT_FOR_YOU   = "101"  # no command found 
        ERR_DONUT_EXEC     = "102"  # execvp failed 
        ERR_DONUT_BAKING   = "103"  # exec command failed 
        """
        
        if not command:
            print "Expected Atleast 1 Argument 'command name', additional arguments will be taken as marionette args"
            return None

        cmd = command+Client.CTRL_E
        # generate the arg
        arg = Client.CTRL_A.join(args)
        # append arg to command
        if arg: cmd += arg+Client.CTRL_E

        # reset the results
        self._reset_result()

        # set the start time
        self.runtime = time.time()
        
        return self._execute(cmd)



if __name__ == '__main__':
    mc = Client(debug = 1)
    mc.execute("ruok")
    print mc.result
    
